{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://hdxgithub.github.io"},"pages":[{"title":"tags","date":"2018-09-08T13:32:12.000Z","updated":"2018-09-08T13:32:12.407Z","comments":true,"path":"tags/index.html","permalink":"https://hdxgithub.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PageName","slug":"PageName-1","date":"2018-09-08T13:31:48.000Z","updated":"2018-09-08T13:31:48.590Z","comments":true,"path":"2018/09/08/PageName-1/","link":"","permalink":"https://hdxgithub.github.io/2018/09/08/PageName-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"PageName","slug":"PageName","date":"2018-09-08T13:31:37.000Z","updated":"2018-09-08T13:31:37.854Z","comments":true,"path":"2018/09/08/PageName/","link":"","permalink":"https://hdxgithub.github.io/2018/09/08/PageName/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"函数，参数及参数结构：练习","date":"2018-08-21T14:51:41.932Z","updated":"2018-08-21T14:50:42.287Z","comments":true,"path":"2018/08/21/函数，参数及参数结构：练习/","link":"","permalink":"https://hdxgithub.github.io/2018/08/21/函数，参数及参数结构：练习/","excerpt":"","text":"函数，参数及参数结构：练习####1,编写一个函数，能够接受至少2个参数，返回最小值和最大值; 123456def double_values(*nums):#元祖的形式 return max(nums),min(nums) double_values(1,2,3)(3,1)#运行结果 123456import random def double_values(*nums): print(nums) return max(nums),min(nums)print(*double_values(*[random.randint(10,20) for _ in range(10)]))#在10到20的范围随机取10个数，打印出选择的随机数，和最大值和最小值 ####2， 编写一个函数，接受一个参数n，n为正整数，左右两种打印方式。要求数字必须对齐 思路一 一行行打印，前面追加空格，每一个空格的宽度等于数字字符串的宽度。 1234567891011121314151617181920212223#两个for循环第一个for循环，循环层数。第二个循环，循环空格，每一个空格的宽度等于数字字符串的宽度。j是倒着打印的，当j和i相等时打印数字。到这打印0取不到前包后不包def triangle_print(n): for i in range(1,n+1): for j in range(n,0,-1): if i &lt; j:#1&lt;11 print(&apos; &apos;*len(str(j)),end = &apos; &apos;) else: print(j,end = &apos; &apos;) print() triangle_print(12) 1 2 1 3 2 1 4 3 2 1 5 4 3 2 1 6 5 4 3 2 1 7 6 5 4 3 2 1 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 1 10 9 8 7 6 5 4 3 2 1 11 10 9 8 7 6 5 4 3 2 1 12 11 10 9 8 7 6 5 4 3 2 1 思路二 右对齐方式。右对齐，最大的问题不知道最后一行多宽？先算出最后一行，知道了宽度，采用右对齐打印，最后补上最后一行。 12345678910111213141516171819202122232425#1,打印最后一行（一个数字加一个空格）。里面有一个循环#2,从第一行打印到n-1行，向右对齐，宽度为ndef triangle_print(n): tail = &quot; &quot;.join([str(i) for i in range(n,0,-1)])#1 width = len(tail) for i in range(1,n): print(&quot;&#123;:&gt;&#123;&#125;&#125;&quot;.format(&quot; &quot;.join([str(j) for j in range(i,0,-1)]),width))#2, print(tail)triangle_print(15) 1 2 1 3 2 1 4 3 2 1 5 4 3 2 1 6 5 4 3 2 1 7 6 5 4 3 2 1 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 1 10 9 8 7 6 5 4 3 2 1 11 10 9 8 7 6 5 4 3 2 1 12 11 10 9 8 7 6 5 4 3 2 1 13 12 11 10 9 8 7 6 5 4 3 2 1 14 13 12 11 10 9 8 7 6 5 4 3 2 115 14 13 12 11 10 9 8 7 6 5 4 3 2 1 思路三基于思路二，能够每一行不重新计算，基于tail等到？ 1234567891011def triangle_print(n): tail = &apos; &apos;.join(str(i) for i in range(n, 0, -1)) width = len(tail) start = -1 step = 2 points = &#123;10*i for i in range(1,3)&#125; # 与其判断两位数、三位数，还不如算好临界值 for i in range(1, n+1): print(&apos;&#123;:&gt;&#123;&#125;&#125;&apos;.format(tail[start:], width)) if i+1 in points: step += 1 start = start - step 1234567891011121314下三角 12 11 10 9 8 7 6 5 4 3 2 1 11 10 9 8 7 6 5 4 3 2 1 10 9 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 1 8 7 6 5 4 3 2 1 7 6 5 4 3 2 1 6 5 4 3 2 1 5 4 3 2 1 4 3 2 1 3 2 1 2 1 1 12345678910111213def showtail(n): tail = &quot; &quot;.join([str(i) for i in range(n,0,-1)]) print(tail) # 无需再次生成列表 for i in range(len(tail)): if tail[i] == &apos; &apos;: print(&apos; &apos;*i,tail[i+1:])showtail(12)#核心思想 遇到一个空格，就把前面全部补成空格后面数字和空格全部打印。由此，可以得到上三角另一种思路 1234567def triangle_print(n): tail = &apos; &apos;.join(str(i) for i in range(n, 0, -1)) width = len(tail) for i in range(-1, -width-1, -1): if tail[i] == &apos; &apos;: print(&apos; &apos;*(width+i),tail[i+1:]) print(tail) ####3 , 笔记 join() [ ] 123456789101112131415#&quot;string&quot;.join(iterable) -&gt;str（返回一个新的字符串）#将可迭代对象连接起来，使用string作为分隔符#可迭代对象本身元素都是字符串#返回一个新字符串#可迭代对象里面的元素必须是字符串才行，如果不是需要转化成字符串。不然会抛异常。用str函数强制转换成字符串Python join()方法用于将序列中的元素以指定的字符连接生成一个新的字符串语法：str.join(sequence);sequence--要连接的元素序列返回值：返回通过指定字符连接序列中元素后生成的最新字符串sequence：（元祖，列表，字典，字符串）seq = &#123;&apos;hello&apos;:&apos;nihao&apos;,&apos;good&apos;:2,&apos;boy&apos;:3,&apos;doiido&apos;:4&#125;print(&apos;-&apos;.join(seq)) #字典只对键进行连接结果：hello-good-boy-doiido format [ ] 12345678910111213141516171819#格式化字符串的函数str,format()#format 函数可以接受不限个参数，位置可以不按顺序。&gt;&gt;&gt;&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 不设置指定位置，按默认顺序&apos;hello world&apos; &gt;&gt;&gt; &quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&apos;hello world&apos; &gt;&gt;&gt; &quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&apos;world hello world&apos;# 通过字典设置参数site = &#123;&quot;name&quot;: &quot;菜鸟教程&quot;, &quot;url&quot;: &quot;www.runoob.com&quot;&#125;print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(**site)) # 通过列表索引设置参数my_list = [&apos;菜鸟教程&apos;, &apos;www.runoob.com&apos;]print(&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;.format(my_list)) # &quot;0&quot; 是必须的 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 11 ‘{:b}’.format(11)‘{:d}’.format(11)‘{:o}’.format(11)‘{:x}’.format(11)‘{:#x}’.format(11) 1011 11 13 b 0xb 0XB 进制 ^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。 表示在正数前显示 +，负数前显示 -； （空格）表示在正数前加空格 b、d、o、x 分别是二进制、十进制、八进制、十六进制。 此外我们可以使用大括号 {} 来转义大括号，如下实例：","categories":[],"tags":[]},{"title":"","slug":"random()模块","date":"2018-08-21T11:22:30.147Z","updated":"2018-08-21T00:50:54.314Z","comments":true,"path":"2018/08/21/random()模块/","link":"","permalink":"https://hdxgithub.github.io/2018/08/21/random()模块/","excerpt":"","text":"random()模块random()方法返回随机生成的一个实数，它在[0,1)范围内 语法 1234import randomrandom.random()0.6535201075880449#在[0,1)中随机产生一个数 注意：random()是不能直接访问的，需要导入random模块，然后通过random静态对象调用该方法。 返回值返回随机生成的一个实数，它在[0，1)范围内。1234567891011121314151617181920212223import random#导入random模块random.randint(a,b)#返回[a,b]之间的整数。产生一个整型随机数。/用于指定范围内的整数。a是上限，b是下限。是一个闭区间。/返回[a,b]之间的整数/random.random()#产生0到1之间的随机浮点数。前闭区间后开区间random.randrange([start,]stop[,step])#从指定范围内，按指定基数递增的集合获取一个随机数，基数缺省值为1.如random.randrange(1,100,2)生产从1到100的间隔为2的随机整数。前包后不包。[0,1)a = [1,3,5,7]#将序列a中的元素顺序打乱random.shuffle(a)#用于将一个列表中的元素打乱，即将列表内的元素随机排列。/随机洗牌。就地修改。print(a)random.sample(sequence)#从样本空间或总体（序列或者集合类型）中随机选取k个不同的元素，返回一个新的列表。sample函数不会修改原有序列。/从指定序列中随机获取指定长度的片段并随机排列。/list,tuple,字符串都属于sequence。参数sequence表示一个有序类型。/可以理解为在一个货架上拿出不同型号的元素random.choice()#从非空序列的元素中随机挑选一个元素，如：random.choice(range(10)),从0到9中随机挑选一个整数。random.choice([1,3,5,7])./从序列中随机选取一个元素/伪随机，假随机。在里面拿出来，东西还在里面。random.uniform(a,b)#用于生成一个指定范围内的随机浮点数，两个参数一个是上限一个是下限。是闭区间。/区间可以不是整数 123456789101112131415161718192021222324252627282930# 1、求和（正确）# 对下面集合中随机取数字，要求取出的数字是3的倍数但不能是4的倍数，成功取到10个数字并对取到的所有数字求和输出a = &#123;5,10,3,8,6,10,9,15,24,30,27,48,24&#125;#类型是seta1 = list(a)#转换成列表形式@@@@@@@@列表转换不熟悉a3 = 0count = 0#计数count2 = 0#计数lst1 = []lst2 = []while True: #循环因为要成功取到10个数 a2 = random.choice(a1)#随机抽取一个数 lst1.append(a2)#每次取的数 count2 +=1#取了多少个数 if a2 % 3 == 0: if a2 % 4 != 0:#如果能整除3不能整除4 lst2.append(a2) a3 += a2 count += 1 if count == 10: breakprint(lst1)#随机取到的数print(lst2)#符合要求的10个数print(a3)#10个数总和print(count2,count)#取了22个数，只有10个数是符合[15, 6, 10, 30, 10, 10, 24, 5, 8, 10, 6, 8, 15, 15, 24, 8, 27, 8, 30, 48, 9, 6][15, 6, 30, 6, 15, 15, 27, 30, 9, 6]15922 10 1234567891011121314151617181920212223242526#1、求和（错误）（第一次思路）#对下面集合中随机取数字，要求取出的数字是3的倍数但不能是4的倍数，成功取到10个数字并对取到的所有数字求和输出import randomp = []count = 0m = 0p2 = []for i in &#123;5,10,3,8,6,10,9,15,24,30,27,48,24&#125;: p.append(i) p1 = random.choice(p) flag = True if p1 % 3 == 0: if p1 % 4 == 0: flag = False else:# p2.append(p1) m += p1 count += 1 if count &gt; 10: break# else:print(m)print(count)57#总和8#8次 12345678910111213141516171819202122232425262728293031323334353637#错误写法#第一次的思路import randomp = []count = 0m = 0p2 = []for i in &#123;5,10,3,8,6,10,9,15,24,30,27,48,24&#125;: p.append(i) p1 = random.choice(p) flag = True if p1 % 3 == 0: if p1 % 4 == 0: flag = False else:# p2.append(p1) m += p1 count += 1 if count &gt; 10: break# else:print(m)print(count)# print(p1) # if p1 % 3 == 0:# if p1 % 4 == 0:# break# else:# m += i# count += 1# if count &gt; 10:# print(m) 123456789101112131415#错误（第一次思路）n = &#123;5,10,3,8,6,10,9,15,24,30,27,48,24&#125;count = 0m = 0for _ in n: if _ % 3 == 0: if _ % 4 == 0: continue else: m += _ count += 1print(m)print(count)# if count &gt; 10:# print(m) 12345678910111213141516171819总结：#第一点a1 = []a = &#123;5,10,3,8,6,10,9,15,24,30,27,48,24&#125;#set类型for i in a: a1.append(i)等效于a = &#123;5,10,3,8,6,10,9,15,24,30,27,48,24&#125;a1 = list(a)列表表示形式需要注意#第二点import randoma2 = random.choice(a1)#这是随机取一个数前面要加循环while True:#或for i in range(100):#因为不知道取多少次才会取10个符合的数#第三点if i % 4 != 0；#如果i不能被4整除。’！=‘不等于。可以不写成if...else了，更加方便","categories":[],"tags":[]},{"title":"字符串","slug":"字符串","date":"2018-08-20T07:28:00.000Z","updated":"2018-08-11T08:08:30.559Z","comments":true,"path":"2018/08/20/字符串/","link":"","permalink":"https://hdxgithub.github.io/2018/08/20/字符串/","excerpt":"","text":"字符串字符串是一个序列，而且是不可变的，因为它是字面常量。 一个字符串一旦定义好就不能改变，因为它是一个字面常量。加出来的它是一个新的字符串和原来的字符串根本就没有关系，因为在内存中的地址根本就不一样。字符串是由一个一个字符组成，一个有序的数列。有序就可以迭代。有序就可以给它编号就支持索引，也支持负索引。 字符串是不可变对象；不可变的字面常量；是一个有顺序的序列； 字符串支持使用索引访问； 冒泡法；快速排序；排序算法； 字符串定义 初始化要注意转义字符；如果不想让它转译就加上一个r前缀； r前缀里面东西不做特殊处理； 三引号要注意的是它里面是可以换行的。把换行符也记录下来。这是三引号的特点。 字符串元素访问–下标字串支持使用索引访问(可以通过下标拿出一个一个字符，但是它本身类型也是字符串的；哪怕只有一个字符也是字符串类型) sql = “seclect * from user where name=’tom’” sql[4]#字符串‘c’ sql[4] = ‘o’ 有序的字符集合，字符序列 for c in sql: print(c) print(type(c))#什么类型？ 可迭代 lst = list(sql) 空格也属于字符串 可迭代：因为它是有顺序的； 字符串join连接* 将可迭代对象连接起来，使用string作为分隔符； 可迭代对象本身元素都是字符串 返回一个新字符串 join方法实际上是对一个可迭代对象操作，但是要求可迭代对象它里面元素必须是字符串，不是字符串会抛异常。这就要求把里面的元素强制转换成字符串。用str函数转换。什么样的对象都可以转换成字符串。（包括自定义的也可以转换）可以理解为所有对象都应该有字符串的表达形式。 加法等拼接完以后返回一个新的字符串。 ‘’.join+（元素为字符串）的可迭代对象；“里面是分隔符； +代表将两个字符串连接在一起，形成一个新字符串； 字符串分割字符串分割的方法分为两类： split系 split(sep=None,maxsplit=-1)-&gt; list of strings 将字符串按照分隔符分割成若干字符串，并返回列表 从左至右 sep指定分隔字符串，缺省的情况下空白字符串作为分隔符 maxsplit指定分割的次数，-1表示遍历整个字符串 split（none,-1)-1代表能切几刀切几刀； 切入点你的东西就不要了（特点就是分隔符不了） rsqlit:从右面开始切，切完以后还是按照返回的还是原来字符串顺序，不会改变。 append返回none \\n换行符：sqlitlines:一行一行切； 常见换行符\\r，\\n，\\r\\n 从左至右； splitlines([Keepends])-&gt;list of strings keepends指的是是否保留行分隔符 行分隔符包括\\n,\\r\\n,\\r等 按照行来切分字符串 会返回一行行数据，每一行就是列表中的一个元素 sep指定分隔符，缺省的情况下空白字符串作为分隔符,没有指定分隔符的时候就是空白字符，尽可能多的切，至少一个包括\\n\\t\\r这种。 partition系 将字符串按照分隔符分割成2段，返回这2段和分隔符的元组 从左至右，遇到分隔符就把字符串分割成两部分 没有找到分隔符，就返回头，2个空元素的三元组 sep分割字符串 ，必须指定 指定只切一刀，返回带上分隔符，返回的是一个元组。（三元组，右半部分，分隔符，左半部分） 一刀两断用，只切一刀。 ’1ab2ab3ab4‘.partition(’ab’) (‘1’,’ab’,’2ab3ab4ab’) 字符串相加效率不会太差 注意：看隐含条件 rpartition(sep)-&gt;(head,sep,tail) 从左至右，遇到分隔符就把字符串分割成两部分，返回头，分隔符，尾三部分的三元组；如果没有找到分隔符，就返回2个空元素和尾的三元组。 字符串大小写upper() 全大写 lower() 全小写 大小写，做判断的时候用 swapcase() 交互大小写 用户在输入时不知道是大小写所以进行转换； uppper() 全大写 lower() 全小写 大小写，做判断的时候用 swapcase() 交互大小写 字符串排版title()-&gt;str 标题的每个单词都大写 title：标题的每个单词都大写 capitalize()-&gt;str 首个单词大写 capitalize：首个单词大写 center(width[,fillchar])-&gt;str width打印宽度 fillchar填充字符 center（width【，fillchar】—） 举例：a = ‘www.0310dreamboy.com&#39; a.center(30); a.center(30,‘@’) zfill(width)-&gt;str zfill(width):width打印宽度，居右，左边用0填充。 ljust(width[,fillchar]):str左对齐 rjust(width[,fillchar]):str右对齐 中文用的少，了解一下 字符串修改* replace(old,new[,count]) - &gt; str:old:要替换的；new： 字符串中找到匹配替换为新子串，返回新字符串 count表示替换几次，不指定就是全部替换 返回一个新的字符串，原字符串是不可变的 strip([chars])-&gt;str 从字符串两端去除指定的字符集chars中的所有字符 如果chars没有指定，去除两端的空白字符 strip之后返回一个新的字符串；空白字符指\\t\\n\\r和空格。空字符串指引号什么也没有的字符串 lstrip([chars])-&gt;str 从左开始 rstrip([chars])-&gt;str 从右开始 字符串查找*find(sub[,start[,end]])-&gt;int: 在指定的区间[start，end），从左至右，查找子串sub。找到返回索引，没找到返回-1 rfind(sub[,start[,end]])-&gt;int 在指定的区间[start,end),从左至右，查找子串sub。找到返回索引，没找到返回-1 返回负数就是在制定的区间内 没找到‘。超界返回负数 index（sub【，sart【，end】】）-&gt;int 没找到抛出异常Value Error，扎到返回索引/ 时间复杂度 时间复杂度index和count方法都是O（n） 随着列表数据规模的增大，而效率下降 len（string） 返回字符串的长度，即字符的个数 count统计出现几次； is isalnum:返回bool值是否是字母和数字组成； isalpha：是否是字母 isdecimal：是否只包含十进制数字 isdigit：是否全部数字 reversed在列表中倒着拿；reverse把整个列表全部倒着排序再打印出来 字符串判断* endswith(suffix[,start[,end]]) -&gt;bool 在指定的区间[start,end),字符串是否是suffix结尾 startswith(prefix[,start[,end]])-&gt;bool 在指定的区间[start,end).字符串是否prefix开头 字符串判断is系列isalnum()-&gt;bool是否是字母和数字组成 isalpha()是否是字母 isdecimal()是否只包含十进制数字 isdigit()是否全部数字(0~9) isidentifier()是不是字母和下划线开头，其他都是字母，数字，下划线 islower()是否都是大小写 isupper()是否全部大写 isspace()是否只包含空白字符 字符串格式化字符串的格式化是一种拼接字符串输出样式的手段，更灵活方便 join拼接只能使用分隔符，且要求被拼接的是可迭代对象 +拼接字符串还算方便，但是非字符串需要先转换成字符串才能拼接 在2.5版本之前，只能使用printf style风格的print输出 print-style formatting，来自于C语言printf函数 格式要求 占位符：使用%和格式字符串组成，例如%s，%d等 s调用str()，r会调用repr().所有对象都可以被这两个转换。 占位符中还可以插入修饰字符，例如%03d表示打印3个位置，不够前面补零 format % values，格式字符串和被格式的值之间使用%分隔 values只能是一个对象，或是一个和格式字符串占位符数目相等的元组，或一个字典12345 printf-style formatting 举例&quot;I am %03d&quot; % (20,)&apos;I like %s.&apos; % &apos;Python&apos;&apos;%3.2f%% , 0x%x, 0X%02X&apos; % (89.7654, 10, 15)&quot;I am %-5d&quot; % (20,) 举例：12345678910111213141516 &apos;i am %d&apos; % 20&apos;i am 20&apos; &apos;i am %d&apos; % (20,)#(20,)他是一个元组后面加上逗号&apos;i am 20&apos;&apos;i am %d %d&apos; % (20,20)#前面是两个占位符后面写两个。有两个空，括号不能去掉，只有一个空可以。如果前面是一个空后面不能写两个数，否则会报错。&apos;i am 20&apos;&apos;%.3f % 1.232546&apos;#小数点以后是控制精度的，四舍五入。&apos;1,233&apos; format函数123456789 format函数格式字符串语法——Python鼓励使用 &quot;&#123;&#125; &#123;xxx&#125;&quot;.format(*args, **kwargs) -&gt; str##返回一个新字符串 args是位置参数，是一个元组 kwargs是关键字参数，是一个字典 花括号表示占位符 &#123;&#125;表示按照顺序匹配位置参数，&#123;n&#125;表示取位置参数索引为n的值 &#123;xxx&#125;表示在关键字参数中搜索名称一致的 &#123;&#123;&#125;&#125; 表示打印花括号  位置参数 &quot;{}:{}&quot;.format(&#39;192.168.1.100&#39;,8888)，这就是按照位置顺序用位置参数替换前面的格式字符串的占位符中 关键字参数或命名参数&quot;{server} {1}:{0}&quot;.format(8888, &#39;192.168.1.100&#39;, server=&#39;Web Server Info : &#39;) ，位置参数按照序号匹配，关键字参数按照名词匹配 访问元素&quot;{0[0]}.{0[1]}&quot;.format((&#39;magedu&#39;,&#39;com&#39;)) 对象属性访问collections import namedtuple123Point = namedtuple(&apos;Point&apos;,&apos;x y&apos;)p = Point(4,5)&quot;&#123;&#123;&#123;0.x&#125;,&#123;0.y&#125;&#125;&#125;&quot;.format(p)  对齐‘{0}{1}={2:&lt;2}’.format(3,2,23)‘{0}{1}={2:&lt;02}’.format(3,2,23)‘{0}{1}={2:&gt;02}’.format(3,2,23)‘{:^30}’.format(‘centered’)‘{:^30}’.format(‘centered’) 进制“int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}”.format(42)“int: {0:d}; hex: {0:#x}; oct: {0:#o}; bin: {0:#b}”.format(42)octets = [192, 168, 0, 1]‘{:02X}{:02X}{:02X}{:02X}’.format(octets)1 浮点数 print(“{}”.format(30.5)) # 1.7320508075688772print(“{:g}”.format(30.5)) # 1.73205print(“{:f}”.format(30.5)) # 1.732051print(“{:10f}”.format(30.5)) # 右对齐print(“{:2}”.format(102.231)) # 宽度为2print(“{:.2}”.format(30.5)) # 1.72个数字print(“{:.2f}”.format(30.5)) # 1.73小数点后2位print(“{:3.2f}”.format(3**0.5)) # 1.73宽度为3，小数点后2位print(“{:3.3f}”.format(0.2745))# 0.275print(“{:3.3%}”.format(1/3)) # 33.333%1建议使用format函数格式化字符串","categories":[{"name":"python","slug":"python","permalink":"https://hdxgithub.github.io/categories/python/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://hdxgithub.github.io/tags/字符串/"}]},{"title":"习题","slug":"习题","date":"2018-08-11T08:06:16.465Z","updated":"2018-08-11T08:12:03.901Z","comments":true,"path":"2018/08/11/习题/","link":"","permalink":"https://hdxgithub.github.io/2018/08/11/习题/","excerpt":"","text":"比较2个数的大小1234567#比较2个数的大小num1=int(input(&apos;&gt;&gt;&apos;))num2=int(input(&apos;&gt;&gt;&apos;))if num1&gt;num2: print(num1)else: print(num2) File &quot;&lt;ipython-input-114-eed8116f8ed3&gt;&quot;, line 3 if num1&gt;num2 print(num1) else print(num2) ^ SyntaxError: invalid syntax num1=int(input(‘&gt;&gt;’))num2=int(input(‘&gt;&gt;’))if num1&gt;num2 print(num1)else print(num2) num1=int(input(‘&gt;&gt;’))num2=int(input(‘&gt;&gt;’))if num1&gt;num2: print(num1)else: print(num2) ####打印九九乘法表 #####no=1 123456#打印九九乘法表#no=1for i in range(1,10):#九九乘法表里的数是两个1到9的数在相乘range（1，10）【1，10）前包后不包 for c in range(1,i+1):#为了避免重复，当i取值1时c取值是1.竖向打印当i取值2时c取值1，2 print(i,&apos;*&apos;,c,&apos;=&apos;,i*c,end=&apos; &apos;)#打印格式i*C=i*c（乘积）中间以空格分开 print()#换行符 1 * 1 = 1 2 * 1 = 2 2 * 2 = 4 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 6 * 1 = 6 6 * 2 = 12 6 * 3 = 18 6 * 4 = 24 6 * 5 = 30 6 * 6 = 36 7 * 1 = 7 7 * 2 = 14 7 * 3 = 21 7 * 4 = 28 7 * 5 = 35 7 * 6 = 42 7 * 7 = 49 8 * 1 = 8 8 * 2 = 16 8 * 3 = 24 8 * 4 = 32 8 * 5 = 40 8 * 6 = 48 8 * 7 = 56 8 * 8 = 64 9 * 1 = 9 9 * 2 = 18 9 * 3 = 27 9 * 4 = 36 9 * 5 = 45 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81 #####no=2 1234567891011#no=2for i in range(1,10): #2 line = &apos;&apos;#定义line是一个字符串 for j in range(1,i+1): product = i*j if j&gt;1 and product &lt; 10:#当j大于1，和乘积小于10时 product = str(product) + &apos; &apos;#乘积后面加两个空格 else: product = str(product) + &apos; &apos;#乘积大于等于10的时候后面加一个空格 line += str(j) + &apos;*&apos; + str(i) + &apos;=&apos; + product#格式1*1=1,字符串相加 print(line) 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 #####no=3 1234567#no=3#&apos;&#123;&#125;&#123;&#125;&#123;&#125;&apos;.format(j,i,i*j)&#123;&#125;代表占位符；j,i,i*j,分别代表对应的位置。#&#123;0&#125;&#123;1&#125;&#123;2&#125;，&#123;2&#125;&#123;1&#125;&#123;0&#125;分别代表顺序；&#123;&#125;&#123;&#125;&#123;:&lt;2&#125;代表乘积左对齐for i in range(1,10): for j in range(1,i+1): print(&apos;&#123;&#125;*&#123;&#125;=&#123;:&lt;&#123;&#125;&#125;&apos;.format(j,i,i*j,2 if j&lt;2 else 3),end=&apos;&apos;)#如果j小于2，乘积后面打两个空格。否则打印三个空格 print() 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 #####no=4 1234567#no=4for i in range(1,10): print(&quot; &quot;*9*(i-1),end=&quot; &quot;) for j in range(i,10): print(&quot;&#123;&#125;*&#123;&#125;=&#123;:&lt;4d&#125;&quot;.format(i,j,i*j),end=&quot; &quot;) #print(i,&apos;*&apos;,j,&apos;=&apos;,i*j,end = &apos; &apos;) print() 1*1=1 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 1*7=7 1*8=8 1*9=9 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 2*7=14 2*8=16 2*9=18 3*3=9 3*4=12 3*5=15 3*6=18 3*7=21 3*8=24 3*9=27 4*4=16 4*5=20 4*6=24 4*7=28 4*8=32 4*9=36 5*5=25 5*6=30 5*7=35 5*8=40 5*9=45 6*6=36 6*7=42 6*8=48 6*9=54 7*7=49 7*8=56 7*9=63 8*8=64 8*9=72 9*9=81 #####no=5 1234567#no=5unit = &apos; &apos;*7for i in range(1,10): print(unit * (i-1), end=&apos;&apos;) for j in range(i,10): print(&apos;&#123;&#125;*&#123;&#125;=&#123;:&lt;&#123;&#125;&#125;&apos;.format(i,j,i*j,3 if j&lt;2 else 3), end=&apos;&apos;) print() 1*1=1 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 1*7=7 1*8=8 1*9=9 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 2*7=14 2*8=16 2*9=18 3*3=9 3*4=12 3*5=15 3*6=18 3*7=21 3*8=24 3*9=27 4*4=16 4*5=20 4*6=24 4*7=28 4*8=32 4*9=36 5*5=25 5*6=30 5*7=35 5*8=40 5*9=45 6*6=36 6*7=42 6*8=48 6*9=54 7*7=49 7*8=56 7*9=63 8*8=64 8*9=72 9*9=81 ####打印图形 #####打印正方形 12345678910#打印图形#打印正方形#no=1n=5e=-n//2#-5//2等于-2for i in range(e,n+e):#（-2，3） if i == e or i == n+e-1: print(&apos;*&apos;*n,sep=&apos; &apos;) else: print(&apos;*&apos; + &apos; &apos;*(n-2) + &apos;*&apos;) ***** * * * * * * ***** 12345678#no=2# n=7# e=-n//1# for i in range(e,n+e):# if i==e or i ==n+e:# print(&apos;*&apos;)# else:# print(&apos;*&apos;*(e+1,n-1)) * --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-42-024b3a40fb94&gt; in &lt;module&gt;() 5 print(&apos;*&apos;) 6 else: ----&gt; 7 print(&apos;*&apos;*(e+1,n-1)) TypeError: can&apos;t multiply sequence by non-int of type &apos;tuple&apos; ####打印菱形 #####no=1 1234567891011#打印菱形#no=1#分两半部分打印n=5a=&apos;*&apos;for i in range(1,n+1,2): t = (n-i)//2#打印空格数 print(&apos; &apos;*t + a*i + &apos; &apos;*t)#格式先打印上半部分1，3，5for i in reversed(range(1,n-1,2)):#reversed反向；3，1 t = (n-i)//2#打印下半部份空格数 print(&apos; &apos;*t + a*i + &apos; &apos;*t)#打印下半部份格式 * *** ***** *** * #####no=1-1 12345678910#no=1-1#分两半部分打印raw = int(input(&quot;please input line number: &quot;))s = &apos;*&apos;for i in range(1,raw+1,2): t = (raw-i)//2 print(&apos; &apos;*t + s*i + &apos; &apos;*t)for i in reversed(range(1,raw-1,2)): t = (raw-i)//2 print(&apos; &apos;*t + s*i + &apos; &apos;*t) please input line number: 5 * *** ***** *** * #####no=2 12345678910#no=2#分两部分打印n=int(input(&apos;please input line number:&apos;))#输入行数a=&apos;*&apos;for i in range(1,n+1,2):#上半部分循环的‘*’数 t = (n-i)//2#打印菱形上半部分空格数 print(&apos; &apos;*t + a*i + &apos; &apos;*t)#打印上半部分格式for i in range(1,n-1,2):#下半部分循环的‘*’数 t = (i+1)//2#打印下半部分空格数 print(&apos; &apos;*t + a*(n-(i+1)) + &apos; &apos;*t)#打印下半部分格式 please input line number:7 * *** ***** ******* ***** *** * #####错误 123456789#错误# n=int(input(&apos;please input line number:&apos;))# a=&apos;*&apos;# for i in range(1,n+1,2):# t = (n-i)//2# print(&apos; &apos;*t + a*i + &apos; &apos;*t)# for i in range(1,n-1,2):# t = (i+1)//2# print(&apos; &apos;*t + a*(n-(i+1)) + &apos; &apos;*t) 12345#打印下半部份（错误）n=7s=&apos;*&apos;for i in range(0,7,2): print(&apos; &apos;*i + s*(n-i) + &apos;&apos;*i ) 12345#错误# n=7# e=n//2# for i in range(-3,4):# print(&apos;&apos;*(n-(e*2)) + &apos;*&apos;*(n-(x*2))) 1234567#打印斐波那契数列#错误# a=1# print(a,end=&apos; &apos;)# for n in range(1,100):# n=(n-1)+(n-2)# print(n,end=&apos; &apos;) 1 -1 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101 103 105 107 109 111 113 115 117 119 121 123 125 127 129 131 133 135 137 139 141 143 145 147 149 151 153 155 157 159 161 163 165 167 169 171 173 175 177 179 181 183 185 187 189 191 193 195 ####打印斐波那契数列（错误：多打印一个数）123456789101112#打印斐波那契数列（错误：多打印一个数）a=1b=1c=2print(a)print(b)print(c)while c&lt;100: a=b b=c c=a+b print(c) 1 1 2 2 3 5 8 13 21 34 55 89 144 #####no=1 123456789#no=1a=1b=1print(a)while b&lt;100:#b进不来超过范围 print(b)#所以打印89 c=a+b#当b=89时a=55，a+b=c=144 a=b#a=89 b=c#b=144 1 1 2 3 5 8 13 21 34 55 89 #####(错误:少打一个1） 1234567891011#(错误:少打一个1）n=int(input(&apos;展示到第几项？&apos;))a=1b=1#a,b两个特殊的数i=1#从1开始计数while i&lt;=n:#打印展示到第10项 print(b)#当第八次时a=55时b=89时，a+b=c=144.a变成89，b变成144这是第十一次while进不去 c=a+b a=b b=c i += 1 展示到第几项？10 1 2 3 5 8 13 21 34 55 89 #####比较两个数的大小 1234567#比较两个数的大小n=7i=5if i&gt;n: print(n,i)else: print(i,n) #####输入两个数，比较大小，升序打印1234567#输入两个数，比较大小，升序打印a = int(input(&apos;please input number a:&apos;))b = int(input(&apos;please input number b:&apos;))if a&gt;b: print(b,a)else: print(a,b) #####比较两个数的大小，三元表达式1234#比较两个数的大小，三元表达式n = int(input(&apos;please input number n:&apos;))m = int(input(&apos;please input number m:&apos;))print(m,n) if n&gt;m else print(n,m) #####求圆的面积和周长123456#求圆的面积和周长pi = 3.14r = float(input(&apos;please input r:&apos;))m = 2*pi*r #圆的周长n = pi*(r**2)#圆的面积print(m,n) please input r:10 62.800000000000004 314.0 #####打印圆的周长和圆的面积no=2 12345#打印圆的周长和圆的面积no=2r = int(input(&apos;please input r:&apos;)) pi = 3.14print(&apos;area=&apos;+str(pi*r*r))print(&apos;cr=&apos;+str(2*pi*r)) #####三个数比较（错误） 12345678910111213#三个数比较（错误）b = input(&apos;&gt;&gt;&apos;)if b != &apos;&apos;: max = int(b) while True: a = input(&apos;&gt;&gt;&apos;) if a == &apos;&apos;: break a = int(a) if a &gt; max: max = a print(max) print(max) &gt;&gt;2 &gt;&gt;14 14 14 12345678910111213#错误三个数比较# b = input(&apos;&gt;&gt;&apos;)# if b != &apos;&apos;:# max = int(b)# while True:# a = input(&apos;&gt;&gt;&apos;)# a = int(a)# if a &gt; max:# max = a# elif:# print(max)# else:# break ####算平均数 12345678#算平均数count = 0 #算平均数的需要知道个数,count = 0用于计数.sum = 0 #算平均数得知道总和while True: num = int(input(&apos;please input number:&apos;)) count +=1 sum += num print(&apos;avg =&apos;,sum / count) 12nums = input().split() #将一行字符串中以1个或多个空格分隔的元素取出放入列表。print(nums[0]+nums[1]) #int将字符转化为整数 19 * 19* 12nums = input().split() print(str(nums)) 12 * [&apos;12&apos;, &apos;*&apos;] #####输入19 *，取值19开平方 12345#输入19 *，取值19开平方a = input().split()import mathb = math.floor(math.sqrt((int(a[0])+1)/2))print(b) 19 * 3 #####输入19 *，打印菱形错误 1234567#输入19 *，打印菱形错误# t = input().split()# import math# f = math.floor(math.sqrt(t[0]+1)/2)# c = t[1]# for i in range（1,t[0],2)# print(c*(2i+f),&apos;&apos;*(i-1)) File &quot;&lt;ipython-input-6-4c1c0cdcb840&gt;&quot;, line 5 for i in range（1,t[0],2) ^ SyntaxError: invalid character in identifier 12t = input().split()print(t[0],t[1]) 12 * 12 * #####输入三个数作比较，错误 12345678910111213141516171819#输入三个数作比较，错误# a = int(input(&apos;&gt;&gt;&apos;))# b = int(input(&apos;&gt;&gt;&apos;))# c = int(input(&apos;&gt;&gt;&apos;))# max = a# if b&gt;c:# print(a,b,c)# else:# print(a,c,b)# max = b# if a&gt;c:# print(b,a,c)# else:# print(b,c,a)# max = c# if a&gt;b: # print(c,a,b)# else:# print(c,b,a) File &quot;&lt;ipython-input-31-0e58d1e2ced7&gt;&quot;, line 6 print(a,b,c) ^ IndentationError: expected an indented block 12345678#三个数比较，错误a = int(input(&apos;&gt;&gt;&apos;))b = int(input(&apos;&gt;&gt;&apos;))c = int(input(&apos;&gt;&gt;&apos;))l = list(a,b,c)import mathmax(list())print(max) &gt;&gt;2 &gt;&gt;15 &gt;&gt;6 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-8-ce306ebee162&gt; in &lt;module&gt;() 2 b = int(input(&apos;&gt;&gt;&apos;)) 3 c = int(input(&apos;&gt;&gt;&apos;)) ----&gt; 4 l = list(a,b,c) 5 import math 6 max(list()) TypeError: list() takes at most 1 argument (3 given) 123456789#三个数比较，错误a = int(input(&apos;&gt;&gt;&apos;))b = int(input(&apos;&gt;&gt;&apos;))c = int(input(&apos;&gt;&gt;&apos;))if a&gt;b and b&gt;c: print(a,b,c)else: print(c,b,a) &gt;&gt;2 &gt;&gt;2 &gt;&gt;0 0 2 2 #####三个数比较，no=1 1234567891011121314#三个数比较，no=1b = int(input(&apos;&gt;&gt;&apos;))m = int(input(&apos;&gt;&gt;&apos;))n = int(input(&apos;&gt;&gt;&apos;))if b&gt;m: if b&gt;n: if m&gt;n: print(b,m,n) else: print(b,n,m) else: print(n,b,m)else: print(n,m,b) &gt;&gt;100000 &gt;&gt;99999 &gt;&gt;5555 100000 99999 5555 123456#三个数比较，错误b = str(input(&apos;&gt;&gt;&apos;))m = str(input(&apos;&gt;&gt;&apos;))n = str(input(&apos;&gt;&gt;&apos;))max(b,m,n)print(max) &gt;&gt;0 &gt;&gt;0 &gt;&gt;2 &lt;built-in function max&gt; #####杨辉三角形，前四行 1234#杨辉三角形，前四行for i in range(4): m = 11**i print(m,end=&apos;\\n&apos;)#\\n代表换行 1 11 121 1331 #####杨辉三角 123456789101112#杨辉三角n = int(input(&apos;&gt;&gt;&apos;))a = [[1],[1,1]]for i in range(2,n): b=a[i-1] c=[1] for j in range(i-1): c.append(b[j]+b[j+1]) c.append(1) a.append(c) for x in a: print(x) &gt;&gt;6 [1] [1, 1] [1, 2, 1] [1, 3, 3, 1] [1, 4, 6, 4, 1] [1, 5, 10, 10, 5, 1] 1234#杨辉三角形（错误）for i in range(4): m = 11**i print(m,end=&apos;\\n&apos;)#\\n代表换行 [1, 1] #####通过用户输入数字计算阶乘 1234567891011121314151617181920#!/usr/bin/python3 # Filename : test.py# author by : www.runoob.com # 通过用户输入数字计算阶乘 # 获取用户输入的数字num = int(input(&quot;请输入一个数字: &quot;))factorial = 1 # 查看数字是负数，0 或 正数if num &lt; 0: print(&quot;抱歉，负数没有阶乘&quot;)elif num == 0: print(&quot;0 的阶乘为 1&quot;)else: for i in range(1,num + 1): factorial = factorial*i print(&quot;%d 的阶乘为 %d&quot; %(num,factorial)) 请输入一个数字: 3 3 的阶乘为 6 123a = [1]#列表追加a.append(1)print(a) [1, 1] 12for i in [2,3,5,7]:#for循环列表 print(i) 2 3 5 7 1234567#杨辉三角n = 6a = [[1],[1,1]]for i in range(2,6)； b = a[1] c = [1] for j in range() File &quot;&lt;ipython-input-6-c3da606c3ca7&gt;&quot;, line 6 b = [:n] ^ SyntaxError: invalid syntax 123456789101112#杨辉三角n = int(input(&apos;&gt;&gt;&apos;))a = [[1],[1,1]]for i in range(2,n): b=a[i-1] c=[1] for j in range(i-1): c.append(b[j]+b[j+1]) c.append(1) a.append(c) for x in a: print(x) &gt;&gt;6 [1] [1, 1] [1, 2, 1] [1, 3, 3, 1] [1, 4, 6, 4, 1] [1, 5, 10, 10, 5, 1] 列表练习1234567891011# 列表练习# 求100内的素数# 从2开始到自身的-1数中找到一个能整除的=》从2开始到自身开平方的数中找到一个能整除的# 一个合数一定可以分解成几个素数的乘积，也就是说，一个数如果能被一个素数整除就是合数# 质数又称素数。一个大于1的自然数，除了1和它自身外，不能整除其他自然数的数叫做质数；否则称为合数。# 使用列表时尾部追加最合适；使用列表时尽量使用索引。一百以内素数有25个； 1234567n = 100 #（100范围内的质数有25个）求100范围内的质数for i in range(2,n): #用for 循环从2到给定的数100 for x in range(2,i):#x的取值范围是2到每次i的取值（按照定义是这么写的，除了1和它自身外 ） if i % x == 0: #如果i能整除x说明它是一个合数 break #他就会停止 else: #否则，它就是一个质数 print(i) #就打印出来 1234567n = 100 #（100范围内的质数有25个）求100范围内的质数for i in range(2,n): #用for 循环从2到给定的数100 for x in range(2,int(i**0.5)+1):#开平方比如当i取值100时开平方10以上的数和10以下的数会有重复有时会带小数点。所以加一。奇偶数， if i % x == 0: break else: print(i) 1234567891011121314#for x in primenumbers: #当i取值2时x没有值进不去所以直接跳过追加到primenumbewrs这个列表里，以此类推3不能整除2所以追加到primenumbers里，现在# 当i取值4时4能整除2所以4是合数，以此类推下去primenumbers里都是质数，也就是验证一个合数一定可以分解成几个素数的乘积，也就是说，一个数如果#能被一个素数整除就是合数这句话。n = 100count = 0primenumbers = [] #给定一个空列表for i in range(2,n): #取值2到100 for x in primenumbers: #当i取值2时x没有值进不去所以直接跳过追加到primenumbewrs这个列表里，以此类推3不能整除2所以追加到primenumbers里 if i % x ==0:#找到了合数 break else: count += 1 primenumbers.append(i)print(count,primenumbers) 25 [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] 123456789101112131415161718n = 100count = 0primenumbers = []flag = False #不是合数for i in range(2,n): edge = i**0.5 for x in primenumbers: if i % x == 0:#如果找到能整除的，就说明找到了质数 flag = True break if x &gt; edge:#如果大于i的开平方还没找到，他就是一个质数.跳出for x in primenumbers循环进入if not flag flag = False break if not flag: count += 1 primenumbers.append(i)print(count,primenumbers) 25 [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import datetime#比较时间差异n = 10000 #（100范围内的质数有25个）求100范围内的质数count = 0start = datetime.datetime.now()for i in range(2,n): #用for 循环从2到给定的数100 for x in range(2,i):#x的取值范围是2到每次i的取值（按照定义是这么写的，除了1和它自身外 ） if i % x == 0: #如果i能整除x说明它是一个合数 break #他就会停止 else: #否则，它就是一个质数 count += 1# print(i) delta = (datetime.datetime.now() - start).total_seconds()print(count)print(&apos;~&apos;*30)print(delta)count = 0primenumbers = [] #给定一个空列表start = datetime.datetime.now()for i in range(2,n): #取值2到100 for x in primenumbers: #当i取值2时x没有值进不去所以直接跳过追加到primenumbewrs这个列表里，以此类推3不能整除2所以追加到primenumbers里 if i % x ==0:#找到了合数 break else: count += 1 primenumbers.append(i)# print(count,primenumbers)print(count)delta = (datetime.datetime.now() - start).total_seconds()print(&apos;~&apos;*30)print(delta)count = 0primenumbers = []start = datetime.datetime.now()flag = False #不是合数for i in range(2,n): edge = i**0.5 for x in primenumbers: if i % x == 0:#如果找到能整除的，就说明找到了质数 flag = True break if x &gt; edge:#如果大于i的开平方还没找到，他就是一个质数.跳出for x in primenumbers循环进入if not flag flag = False break if not flag: count += 1 primenumbers.append(i)# print(count,primenumbers)print(count)delta = (datetime.datetime.now() - start).total_seconds()print(&apos;~&apos;*30)print(delta) 1229 120.5395951229 0.06474 1229 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 0.009993#####大于3的素数只有6N-1和6N+1两种形式```#大于3的素数只有6N-1和6N+1两种形式n = 100 #100以内素数count = 2#因为从5开始所以计数从2开始x = 5#起步为5step = 2#规律5 7 11 13 规律为加2加4primenumbers = [2,3]#给出一个列表（2，3）比较特殊所以从5开始，while x &lt;= n:#x取值小于等于100（给出的范围值） for i in range(3,int(x**0.5)+1,2):#从5开始都是奇数所以2就没必要测试直接从3开始，“这个地方还可以优化，range(3,int(x**0.5)+1,2)可以利用上次求出的值 if x % i == 0:#如果能整除就说明它是合数 break else: primenumbers.append(x)#在这个列表里追加x取值（追加质数） count += 1#计数加1 x += step#x加2 step = 4 if step == 2 else 2#step如果刚加完2它现在就是4，如果是4加2print(count,primenumbers)#循环完打印``` 25 [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]```#大于3的素数只有6N-1和6N+1两种形式n = 100 #100以内素数count = 2x = 5#起步为5step = 2#5 7 11 13 规律加2加4primenumbers = [2,3]#给出一个列表（2，3）比较特殊，从5开始b = []#把每一次求出的值利用起来，一个合数一定可以分解成几个素数的乘积，也就是说，一个数如果能被一个素数整除就是合数。利用起来上一次求出的值。while x &lt;= n:#取值范围在小于等于n for i in b:#如果可以整出，它就是合数。找到合数的意思 if x % i == 0: break else: primenumbers.append(x)#在这个列表里追加x的值 count += 1#计数加1 b.append(x)#追加上一次的值 x += step#x加2 step = 4 if step == 2 else 2#step如果是2现在是4，如果是4现在是2print(count,primenumbers)#循环完打印``` 25 [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]```import datetime#大于3的素数只有6N-1和6N+1两种形式n = 100 #100以内素数start = datetime.datetime.now()count = 2x = 5#起步为5step = 2primenumbers = [2,3]while x &lt;= n: for i in range(3,int(x**0.5)+1,2): if x % i == 0: break else: primenumbers.append(x) count += 1 x += step step = 4 if step == 2 else 2print(count,primenumbers)pdelta = (datetime.datetime.now() - start).total_seconds()print(&apos;~&apos;*30)print(delta)#大于3的素数只有6N-1和6N+1两种形式start = datetime.datetime.now()#n = 100 #100以内素数count = 2x = 5#起步为5step = 2primenumbers = [2,3]b = []while x &lt;= n: for i in b: if x % i == 0: break else: primenumbers.append(x) count += 1 b.append(x) x += step step = 4 if step == 2 else 2print(count,primenumbers)pdelta = (datetime.datetime.now() - start).total_seconds()print(&apos;~&apos;*30)print(delta)``` 25 [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] 0.009993 25 [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 0.009993 1234567n = int(input(&apos;&gt;&gt;&apos;))for i in range(2,n): for x in [2,3,5,7]: if i % x == 0: break else: print(i) 123456789101112#求100以内的素数(错误)n = int(input(&apos;please input prime number(素数）&gt;&gt;：&apos;))flag = n * [1]p = 2while p &lt;= n: print (p) for i in range(2*p,n,p): flag[i] = 0 while True: p += 1 if (flag[p]) == 1: break please input prime number(素数）&gt;&gt;：100 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-15-d7d14ec58604&gt; in &lt;module&gt;() 9 while True: 10 p += 1 ---&gt; 11 if (flag[p]) == 1: 12 break IndexError: list index out of range 123456789101112n = 100count = 0primenumbers = []for x in range(2,n): for i in range(2,int(x**0.5)+1): if x % i == 0: break else: count += 1 primenumbers.append(x)print(count)print(primenumbers) 25 [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","categories":[{"name":"python","slug":"python","permalink":"https://hdxgithub.github.io/categories/python/"}],"tags":[{"name":"习题","slug":"习题","permalink":"https://hdxgithub.github.io/tags/习题/"}]},{"title":"线性结构","slug":"线性结构","date":"2018-08-11T07:55:09.574Z","updated":"2018-08-11T07:28:17.197Z","comments":true,"path":"2018/08/11/线性结构/","link":"","permalink":"https://hdxgithub.github.io/2018/08/11/线性结构/","excerpt":"","text":"线性结构切片是对于线性结构来讲 可迭代的；for in；可迭代的不一定是线性结构； len（）可以获取长度 通过下标可以访问 可以切片 ####学过的内置线性结构： 列表，元组，字符串，bytes，bytearray 不可变的：元祖，字符串，bytes 可变的：列表，bytearray 切片 通过索引区间访问的线性结构的一段数据 sequence[start:stop]表示返回[start,stop]区间的子序列 支持负索引 start为0，可以省略 stop为末尾，可以省略 超过上界（右边界），就取到末尾；超过下界（左边界），取到开头 start一定要在stop的左边 [:]表示从头到尾，全部元素被取出。等效于copy()方法 切片举例a[:]可以拷贝一个字序列出来，等效于a.copy() print(‘www.0310dreamboy.com&#39;[4:10]) print(‘www.0310dreamboy.com&#39;[:10]) print(‘www.0310dreamboy.com&#39;[4:]) print(‘www.0310dreamboy.com&#39;[:]) print(‘www.0310dreamboy.com&#39;[:-1]) print(‘www.0310dreamboy.com&#39;[4:-4]) print(‘www.0310dreamboy.com&#39;[4:50])右边超过边界好多 print(b’www.0310dreamboy.com&#39;[-40:10])相当于从0到10，左边超过边界好多；返回类型是bytes。取序列是取它子序列并不改变类型。 print(bytearray(b’www.0310dreamboy.com&#39;)[-4:10]) print(tuple(‘www.0310dreamboy.com&#39;)[-10:10]) print(list(‘www.0310dreamboy.com&#39;)[-10:-4]) 所谓子序列是copy出来的子序列，他是占内存空间的。 运行结果12345678910110310drwww.0310dr0310dreamboy.comwww.0310dreamboy.comwww.0310dreamboy.co0310dreamboy0310dreamboy.comb&apos;www.0310dr&apos;bytearray(b&apos;&apos;)()[&apos;e&apos;, &apos;a&apos;, &apos;m&apos;, &apos;b&apos;, &apos;o&apos;, &apos;y&apos;] 步长切片 [start:stoop:step] step为步长，可以为正，负整数，默认是1 step要和start：stop同向，否返回空序列 ‘www.0310dreamboy.com&#39;[4:10:2] list(‘www.0310dreamboy.com&#39;)[4:10:-2] tuple(‘www.0310dreamboy.com&#39;)[-10:-4:2] b’www.0310dreamboy.com&#39;[-4:-10:2] bytearray(b’www.0310dreamboy.com&#39;)[-4:-10:-2] 运行结果1234501d&apos;[](&apos;e&apos;, &apos;m&apos;, &apos;o&apos;)b&apos;&apos;bytearray(b&apos;.om&apos;)s","categories":[{"name":"python","slug":"python","permalink":"https://hdxgithub.github.io/categories/python/"}],"tags":[{"name":"线性结构","slug":"线性结构","permalink":"https://hdxgithub.github.io/tags/线性结构/"}]},{"title":"列表练习","slug":"列表练习","date":"2018-08-10T07:15:17.000Z","updated":"2018-08-10T13:00:12.923Z","comments":true,"path":"2018/08/10/列表练习/","link":"","permalink":"https://hdxgithub.github.io/2018/08/10/列表练习/","excerpt":"","text":"列表练习使用列表时尽量使用索引，尽量不要用remove,inserd 求100内的素数： 杨辉三角：练习补零； 知道未来要用多少个，开辟好空间，来替换的效率会很好。 列表能用的就是索引，知道避免什么， 列表查询速度快；列表不能一直扩大；不要一直频繁丢弃；一小批一小批处理；要了解内存状况；","categories":[{"name":"python","slug":"python","permalink":"https://hdxgithub.github.io/categories/python/"}],"tags":[{"name":"列表","slug":"列表","permalink":"https://hdxgithub.github.io/tags/列表/"}]},{"title":"元祖","slug":"数据结构元祖：","date":"2018-08-09T14:20:33.933Z","updated":"2018-08-11T08:13:39.494Z","comments":true,"path":"2018/08/09/数据结构元祖：/","link":"","permalink":"https://hdxgithub.github.io/2018/08/09/数据结构元祖：/","excerpt":"","text":"数据结构元祖： 排序算法：一个有序的元素组成的集合；优势更省内存 元祖是不可变对象；（在什么情况下是可变的；） 使用（）表示； t = tuple()元祖不支持赋值 容器对象都是一个可迭代是对象；t2 = (2,)一个元素的元组； 元祖加元祖返回一个新元组，不是就地修改。元祖支持索引（下标） 元祖不可通过索引赋值； 元祖是只读的，所以增，删，改方法都没有； 命名元祖：collections收集； from collections import namedtuple;导入 Point变量，标识符 _p(x=4,y=5)给人看的，字符串表达形式；.代表对象下面是什么东西 冒泡法： 优化点是在哪一趟提前结束 object:对象；callable:调用","categories":[{"name":"python","slug":"python","permalink":"https://hdxgithub.github.io/categories/python/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://hdxgithub.github.io/tags/数据结构/"}]},{"title":"数字处理函数","slug":"数字的处理函数：","date":"2018-08-09T14:20:32.470Z","updated":"2018-08-11T08:13:02.250Z","comments":true,"path":"2018/08/09/数字的处理函数：/","link":"","permalink":"https://hdxgithub.github.io/2018/08/09/数字的处理函数：/","excerpt":"","text":"数字的处理函数： import math import.floor(floor地板)（）；math.ceil(ceil天花板)（）； int(2.5),int(3.5)；取整数部分，小数点以后不关心 （2，3） int(-2.5),int(-3.5) (-2,-3) 3//2 1 3//-2 -2 “//”这个整除是向下取整 round()四舍六入，五取偶； “/”表示自然除， 列表list: 列表就像一个排列整齐的队伍； 可索引，线性结构，可变可迭代的， lst = []表示空列表/比较常用","categories":[{"name":"python","slug":"python","permalink":"https://hdxgithub.github.io/categories/python/"}],"tags":[{"name":"数字处理","slug":"数字处理","permalink":"https://hdxgithub.github.io/tags/数字处理/"}]},{"title":"杨辉三角","slug":"杨辉三角形","date":"2018-08-09T14:20:28.793Z","updated":"2018-08-11T08:14:20.873Z","comments":true,"path":"2018/08/09/杨辉三角形/","link":"","permalink":"https://hdxgithub.github.io/2018/08/09/杨辉三角形/","excerpt":"","text":"12345678910111213一行一行追加，通过上一行算出下一行。n = int(input(&apos;&gt;&gt;&apos;)) #输入几行a = [[1],[1,1]] #第0行和第行，特殊的两行for i in range(2,n): #从第2行开始循环到第n行 b=a[i-1] #b = [1,1]每次求的那行的上一行 c=[1] #行首1 for j in range(i-1):#每一行循环几次 c.append(b[j]+b[j+1])#每一次循环得到的数（每一行的中间几个数） c.append(1) #行尾追加1 a.append(c) #在a这个大列表当中追加每一行地数for x in a: print(x)","categories":[{"name":"python","slug":"python","permalink":"https://hdxgithub.github.io/categories/python/"}],"tags":[{"name":"杨辉三角","slug":"杨辉三角","permalink":"https://hdxgithub.github.io/tags/杨辉三角/"}]}]}